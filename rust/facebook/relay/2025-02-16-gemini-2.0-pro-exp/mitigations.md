# Mitigation Strategies Analysis for facebook/relay

## Mitigation Strategy: [Persisted Queries with Relay](./mitigation_strategies/persisted_queries_with_relay.md)

*   **Description:**
    1.  **Enable Persisted Queries in `relay-compiler`:**  Within your Relay project, locate the configuration for `relay-compiler` (often in `package.json` or a dedicated configuration file).  Add the necessary configuration to enable persisted query generation.  This typically involves setting a flag like `--persist-output <path/to/output.json>` or a similar option, specifying where the mapping of query IDs to query text should be saved.
    2.  **Run `relay-compiler`:** Execute the `relay-compiler` command. This will analyze your Relay components (which contain your GraphQL queries and fragments) and generate the persisted query artifacts.  The output file (e.g., `output.json`) will contain a JSON object where keys are unique query IDs (hashes) and values are the corresponding GraphQL query strings.
    3.  **Server-Side Integration (Query Map):**  Your GraphQL server needs to be aware of these persisted queries.  This involves:
        *   **Loading the Query Map:**  On server startup, load the JSON file generated by `relay-compiler` into memory (or a fast lookup store). This creates a mapping of query IDs to query text.
        *   **Modifying the GraphQL Endpoint:**  Adjust your GraphQL endpoint to *expect* a query ID (instead of the full query text) in the request.  The request payload might look like `{ "id": "someQueryId" }`.
        *   **Lookup and Execution:**  When a request arrives, the server uses the provided `id` to look up the corresponding query text in the loaded map.  If found, the server executes that query. If not found, the server returns an error (indicating an invalid or unknown query ID).
    4.  **Relay Client (Automatic):**  The crucial point here is that the Relay client, when configured to use persisted queries, *automatically* handles sending the query ID instead of the full query text.  You don't need to manually modify your Relay components or network layer.  Relay takes care of this transparently.
    5.  **Testing:** Thoroughly test the entire flow:
        *   Verify that `relay-compiler` generates the correct output file.
        *   Ensure the server correctly loads the query map.
        *   Confirm that the Relay client sends only query IDs.
        *   Test with valid and invalid query IDs to ensure proper error handling.

*   **Threats Mitigated:**
    *   **Over-fetching and Data Exposure via Introspection (Severity: High):**  Indirectly mitigates this by restricting the possible queries to the pre-defined set. Even if introspection were somehow enabled, an attacker couldn't execute arbitrary queries.
    *   **Query Complexity Attacks (DoS) (Severity: High):**  Completely prevents arbitrary complex queries. Only pre-approved (and presumably vetted for complexity) queries can be executed.
    *   **Field Suggestion Attacks (Severity: Medium):**  Indirectly mitigates this, as the attack surface is limited to the known, persisted queries.
    *   **Reliance on Client-Side Security (Severity: High):**  This is a key benefit.  Persisted queries enforce server-side control over what queries are allowed, preventing a compromised client from sending malicious queries.

*   **Impact:**
    *   **Over-fetching and Data Exposure via Introspection:** Risk significantly reduced.
    *   **Query Complexity Attacks (DoS):** Risk almost eliminated.
    *   **Field Suggestion Attacks:** Risk reduced.
    *   **Reliance on Client-Side Security:** Risk significantly reduced.

*   **Currently Implemented:**
    *   Not currently implemented.

*   **Missing Implementation:**
    *   Full implementation is required. This includes configuring `relay-compiler`, setting up the server-side query map loading and lookup logic, and verifying the Relay client's automatic use of query IDs.

## Mitigation Strategy: [Utilize Relay's Data Masking (with caution and server-side enforcement)](./mitigation_strategies/utilize_relay's_data_masking__with_caution_and_server-side_enforcement_.md)

*   **Description:**
    1.  **Understand Data Masking:** Relay's data masking is a *client-side* feature designed to prevent accidental access to data that hasn't been explicitly requested in a GraphQL fragment.  It *does not* provide server-side security.  It's a development aid to prevent over-fetching *by the developer*, not a security mechanism against malicious actors.
    2.  **Server-Side Validation is Paramount:**  *Never* rely solely on Relay's data masking for security.  Always implement robust server-side authorization and validation, as described in previous responses (field-level authorization, etc.).
    3.  **How it Works (Client-Side):** When you define a fragment in Relay, you specify the fields you need from a particular type.  Relay's data masking ensures that, within your component, you can only access those explicitly requested fields.  Attempting to access a field that wasn't included in the fragment will result in an error *during development*.
    4.  **Limitations:**  A malicious user can easily bypass this client-side masking by modifying the client-side code.  Therefore, it's *not* a security feature against attackers.
    5.  **Use Case (Development Aid):**  The primary benefit is to help developers avoid accidentally over-fetching data and to enforce a clear contract between components and the data they require.  It helps prevent unintentional data exposure *within the application's own code*.
    6. **Implementation:** Data masking is built into how you define fragments using graphql template literals.

*   **Threats Mitigated:**
    *   **Accidental Over-fetching (by Developers) (Severity: Low):** Helps prevent developers from unintentionally requesting more data than necessary, which can improve performance and reduce the risk of exposing unnecessary data *within the application*.  This is *not* a mitigation against malicious actors.

*   **Impact:**
    *   **Accidental Over-fetching (by Developers):** Risk reduced during development.  No impact on security against external threats.

*   **Currently Implemented:**
    *   Partially Implemented - Relay's data masking is inherently part of how fragments are defined and used. However, the critical missing piece is the understanding and enforcement of the fact that this is *not* a security mechanism against malicious actors.

*   **Missing Implementation:**
    *   The key missing element is the *explicit understanding and documentation* that Relay's data masking is *not* a security feature against external threats.  Developers need to be trained to understand this limitation and to rely solely on server-side validation and authorization for security.  Code reviews should specifically check for any reliance on client-side data masking for security purposes.

