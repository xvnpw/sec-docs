# Attack Surface Analysis for leptos-rs/leptos

## Attack Surface: [Untrusted Data in Server-Rendered Initial State](./attack_surfaces/untrusted_data_in_server-rendered_initial_state.md)

*   **Description:** Embedding unsanitized user data directly into the HTML generated by Leptos's server-side rendering (SSR) can lead to XSS vulnerabilities that execute *before* client-side JavaScript loads. This is a *server-side* XSS, distinct from typical client-side XSS.
*   **How Leptos Contributes:** Leptos's SSR is a core feature, and the initial state is often populated with data fetched on the server. This creates a direct and *primary* path for injecting malicious data *before* any client-side defenses can activate. This is a defining characteristic of how Leptos handles initial rendering.
*   **Example:** A blog comment (stored in a database) containing `<script>alert('XSS')</script>` is directly inserted (without escaping) into the HTML generated for a blog post page. When a user visits the page, the script executes immediately in the user's browser, even before Leptos's client-side code runs.
*   **Impact:** Execution of arbitrary JavaScript in the user's browser, potentially leading to session hijacking, data theft, cookie stealing, or defacement. The attacker gains full control of the user's interaction with the site.
*   **Risk Severity:** Critical
*   **Mitigation Strategies:**
    *   **Mandatory Server-Side Sanitization:** *Always* and rigorously sanitize *all* data used in SSR on the *server* using a robust HTML escaping library specifically designed for this purpose. Treat *all* data fetched from databases, APIs, or user input as potentially malicious, regardless of any prior client-side validation. Escape data appropriately for its HTML context (attribute values, text content, etc., require different escaping).
    *   **Content Security Policy (CSP):** Implement a strict CSP to limit the sources from which scripts can be executed. This acts as a crucial defense-in-depth measure, mitigating the impact even if sanitization has flaws.
    *   **Input Validation (Pre-Storage):** Validate user input *before* storing it in the database. While not a replacement for server-side sanitization, this reduces the risk of malicious data entering the system.

## Attack Surface: [Server Function Abuse](./attack_surfaces/server_function_abuse.md)

*   **Description:** Leptos server functions (`#[server]`) expose API endpoints. Attackers can attempt to exploit these endpoints through various means, including malformed input, denial-of-service (DoS) attacks, and bypassing authorization.
*   **How Leptos Contributes:** The `#[server]` macro *automatically* generates these endpoints, making them a readily available and well-defined target. The serialization/deserialization handled by Leptos for these functions is also a key part of the attack surface.
*   **Example:**
    *   **Malformed Input:** An attacker sends a request to a server function with an unexpected data type, a very large string, or a deeply nested object, hoping to trigger an error, a crash, or unexpected behavior in the server-side logic.
    *   **DoS:** An attacker sends a flood of requests to a server function, overwhelming the server and making the application unavailable to legitimate users.
    *   **Bypassing Authorization:** An attacker calls a server function that *should* require authentication *without* providing valid credentials, hoping to bypass security checks that were incorrectly implemented (or omitted) within the server function itself.
*   **Impact:** Denial of service, data breaches, unauthorized access to sensitive resources or functionality, server crashes, potential for remote code execution (RCE) in severe cases.
*   **Risk Severity:** High
*   **Mitigation Strategies:**
    *   **Strict Input Validation (Server-Side):** Implement robust input validation *within each server function* using a dedicated validation library (e.g., `validator` crate). Define and enforce strict schemas for the expected input types, sizes, and formats. *Never* rely solely on client-side validation.
    *   **Mandatory Rate Limiting:** Implement rate limiting on *all* server function endpoints to prevent DoS attacks. Use a reverse proxy (like Nginx) or a Rust crate like `governor`.
    *   **Authentication and Authorization (Inside Server Functions):** Perform authentication and authorization checks *within each server function* that requires them. Do *not* rely solely on external middleware or client-side checks. The server function is the *definitive* point of enforcement.
    *   **Payload Size Limits:** Enforce strict limits on the size of request payloads, both at the web server level (e.g., using Nginx configuration) and within the Leptos application (checking the size of deserialized data).
    *   **Robust Error Handling:** Implement comprehensive error handling to prevent information leakage and ensure the application remains stable under attack. Avoid exposing internal error details to the client.

## Attack Surface: [Deserialization of Untrusted Data](./attack_surfaces/deserialization_of_untrusted_data.md)

*   **Description:** Leptos uses serialization/deserialization (often with `serde` and a format like `bincode` or `cbor`) to transfer data between the client and server, particularly for server functions. If an attacker can control the serialized data sent to the server, they might be able to exploit vulnerabilities in the deserialization process. This is a classic "deserialization of untrusted data" vulnerability.
*   **How Leptos Contributes:** Leptos *fundamentally relies* on serialization/deserialization for its client-server communication model, especially for server functions. This makes it a core part of the attack surface. The choice of serialization format (configured via Leptos features) directly impacts the vulnerability landscape.
*   **Example:** An attacker crafts a malicious serialized payload that, when deserialized by the server (within a server function), triggers a vulnerability in the deserialization library or exploits type confusion in the application code, potentially leading to remote code execution.
*   **Impact:** Remote code execution (RCE) on the server, denial of service, data corruption, potential for complete server compromise.
*   **Risk Severity:** High
*   **Mitigation Strategies:**
    *   **Avoid Untrusted Deserialization (Preferred):** If at all possible, design the application's architecture to *avoid* deserializing data directly from user-controlled input. This is the most secure approach.
    *   **Safe Serialization Formats and Libraries:** Use a well-vetted and secure serialization format and library. While `bincode` is generally considered safer than some alternatives, *no* serialization format is inherently immune to all vulnerabilities.
    *   **Schema Validation (Pre-Deserialization):** If feasible, validate the *structure* of the serialized data *before* attempting to deserialize it. This can help prevent some classes of deserialization attacks.
    *   **Leverage Rust's Type System:** Utilize Rust's strong type system to minimize the risk. Avoid using overly generic types (like `serde_json::Value`) when deserializing untrusted data. Define specific, well-defined structs for deserialization.
    *   **Input Validation (Post-Deserialization):** Even *after* successful deserialization, rigorously validate the resulting data to ensure it conforms to all expected constraints and business rules. This is a critical defense-in-depth step.

