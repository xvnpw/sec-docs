# Attack Surface Analysis for cube-js/cube

## Attack Surface: [SQL Injection via Cube Query Generation](./attack_surfaces/sql_injection_via_cube_query_generation.md)

**Description:**  Malicious SQL code is injected into queries generated by Cube.js, potentially leading to unauthorized data access, modification, or deletion on the underlying database.

**How Cube Contributes:** If user-provided data (directly or indirectly through Cube's data model or filters) is not properly sanitized or parameterized before being incorporated into the SQL queries generated by Cube.js, it creates an entry point for SQL injection.

**Example:** A user-controlled filter value in a Cube.js API request is crafted to include SQL injection payloads. Cube.js, without proper input validation, incorporates this into the generated SQL query, executing the malicious code on the database. For instance, a filter like `{"dimension": "users.name", "operator": "equals", "values": ["' OR '1'='1' --"]}` could bypass intended filtering.

**Impact:** Critical. Complete compromise of the database, including data breaches, data manipulation, and potential denial of service.

**Risk Severity:** Critical

**Mitigation Strategies:**
* **Always use parameterized queries or prepared statements:** Ensure Cube.js and any custom code interacting with the database utilize parameterized queries to prevent direct injection of SQL.
* **Strict input validation and sanitization:** Validate and sanitize all user-provided input that could influence query generation, including filter values, dimension/measure selections (if dynamically controlled), and time ranges.
* **Principle of Least Privilege for Database User:** Grant the database user used by Cube.js only the necessary permissions required for its operation, limiting the impact of a successful SQL injection.
* **Regular security audits and code reviews:** Review Cube.js schema definitions, custom logic, and API endpoints for potential SQL injection vulnerabilities.

## Attack Surface: [Overly Permissive GraphQL Queries and Data Exposure](./attack_surfaces/overly_permissive_graphql_queries_and_data_exposure.md)

**Description:** The Cube.js GraphQL API allows for queries that retrieve excessive amounts of data or expose sensitive information that should not be accessible to certain users.

**How Cube Contributes:** The flexibility of GraphQL allows clients to request specific data points. If the Cube.js data model and security contexts are not carefully designed, it might allow for overly broad queries that bypass intended data access restrictions.

**Example:** A user with limited permissions is able to craft a GraphQL query that joins multiple tables and retrieves sensitive data from a dimension they shouldn't have access to, due to a lack of granular authorization controls in Cube.js.

**Impact:** High. Potential for significant data breaches and exposure of confidential information.

**Risk Severity:** High

**Mitigation Strategies:**
* **Implement granular authorization using Cube.js Security Contexts:** Define and enforce fine-grained access control rules based on user roles, attributes, or other relevant factors within Cube.js security contexts.
* **Carefully design the Cube.js data model:** Avoid exposing sensitive data directly in dimensions or measures accessible to a wide range of users. Consider data masking or aggregation techniques.
* **Implement query complexity analysis and limits:**  Analyze the complexity of incoming GraphQL queries and reject those exceeding predefined limits to prevent resource exhaustion and excessive data retrieval.
* **Regularly review and audit GraphQL schema and security rules:** Ensure the schema and security contexts align with the principle of least privilege and effectively restrict data access.

## Attack Surface: [Exposure of Cube API Keys/Tokens in Client-Side Code](./attack_surfaces/exposure_of_cube_api_keystokens_in_client-side_code.md)

**Description:**  API keys or authentication tokens required to access the Cube API are inadvertently embedded directly in client-side JavaScript code, making them accessible to anyone inspecting the client-side application.

**How Cube Contributes:** Developers might mistakenly include API keys or tokens in their frontend code when configuring the `@cubejs-client` library to interact with the Cube API.

**Example:**  The `cubejsApi` object in a React application is initialized with an API token directly in the component's code: `const cubejsApi = cubejs('YOUR_API_TOKEN', ...);`. This token is visible in the browser's developer tools.

**Impact:** High. Attackers can use the exposed API keys or tokens to make unauthorized requests to the Cube API, potentially accessing or manipulating data.

**Risk Severity:** High

**Mitigation Strategies:**
* **Never embed API keys or sensitive tokens directly in client-side code:**  Store API keys securely on the server-side and use secure authentication flows (e.g., session-based authentication, OAuth 2.0) to manage access to the Cube API.
* **Utilize backend for frontend (BFF) pattern:** Implement a backend service that acts as an intermediary between the frontend and the Cube API, handling authentication and authorization securely on the server-side.
* **Environment variables for sensitive configuration:** Store API keys and other sensitive configuration in environment variables on the server and access them securely.

## Attack Surface: [Database Credentials Exposure in Configuration](./attack_surfaces/database_credentials_exposure_in_configuration.md)

**Description:** Database credentials used by Cube.js to connect to data sources are stored insecurely, making them vulnerable to exposure.

**How Cube Contributes:** Cube.js requires database connection details, which are often configured in `.env` files or configuration files used by the Cube.js server. If these files are not properly secured, the credentials can be compromised.

**Example:** Database credentials are hardcoded in the `cube.js` configuration file or stored in a plain text `.env` file committed to a public Git repository used by the Cube.js deployment.

**Impact:** Critical. Full compromise of the database, allowing attackers to access, modify, or delete data.

**Risk Severity:** Critical

**Mitigation Strategies:**
* **Use secure credential management solutions:** Utilize environment variables, secrets management tools (e.g., HashiCorp Vault, AWS Secrets Manager), or cloud provider-specific secret storage mechanisms to store database credentials securely.
* **Avoid hardcoding credentials:** Never hardcode database credentials directly in configuration files or code used by Cube.js.
* **Restrict access to configuration files:** Ensure that configuration files containing sensitive information are not publicly accessible and have appropriate access restrictions on the server where Cube.js is running.
* **Regularly rotate database credentials:** Periodically change database passwords to limit the window of opportunity for attackers if credentials are compromised.

## Attack Surface: [Denial of Service (DoS) via Resource-Intensive Queries](./attack_surfaces/denial_of_service__dos__via_resource-intensive_queries.md)

**Description:** Attackers craft complex or resource-intensive queries through the Cube API that overwhelm the Cube Store or the underlying database, leading to a denial of service for legitimate users.

**How Cube Contributes:** Cube.js exposes an API that allows users to define and execute queries. If there are no safeguards within Cube.js or the application using it against overly complex or resource-intensive queries, it can be exploited for DoS attacks.

**Example:** An attacker sends a GraphQL query to the Cube API that joins a large number of tables, performs complex aggregations on massive datasets, or retrieves an extremely large number of records without proper pagination, causing the database or Cube Store to become unresponsive.

**Impact:** High. Disruption of service, impacting the availability of the application and potentially leading to financial losses or reputational damage.

**Risk Severity:** High

**Mitigation Strategies:**
* **Implement query complexity analysis and limits within Cube.js:** Configure Cube.js to analyze the complexity of incoming queries based on factors like the number of joins, aggregations, and filters, and reject queries exceeding predefined thresholds.
* **Set resource limits on the Cube Store and database:** Configure resource limits (e.g., CPU, memory, connection limits) for both the Cube Store instance and the underlying database to prevent a single malicious query from consuming all resources.
* **Implement rate limiting on the Cube API:** Limit the number of requests that can be made to the Cube API from a single IP address or user within a specific timeframe.
* **Proper indexing and database optimization:** Ensure the underlying database is properly indexed and optimized to handle a large volume of queries efficiently, which can help mitigate the impact of some DoS attempts.

