- **Vulnerability Name:** Server‐Side Request Forgery (SSRF) via Unsanitized Station Code
  - **Description:**
    An attacker who can control the value stored in the Station model’s “code” field may supply a malicious value. In the method `load_weather` (located in `tests/weather/models.py`), the URL for downloading weather data is generated by string substitution without any sanitization:
    ```
    DATA_URL = "https://www.ncei.noaa.gov/access/past-weather/{code}/data.csv"
    …
    response = requests.get(DATA_URL.format(code=self.code))
    ```
    An attacker who has access to create or update a Station record can inject a value for “code” that points to an internal or malicious endpoint. This causes the server to initiate an HTTP request to an attacker‐controlled target.

  - **Impact:**
    If exploited the server will send HTTP requests to arbitrary destinations. This may allow an attacker to:
    • Probe internal network resources (bypassing firewall restrictions).
    • Exfiltrate sensitive information from internal endpoints.
    • Possibly leverage the server as a proxy in further attacks.

  - **Vulnerability Rank:** High
  - **Currently Implemented Mitigations:**
    None. The code simply uses string formatting to build the URL without any validation or sanitation of the `code` field.

  - **Missing Mitigations:**
    • Validate and restrict the allowed values for the station “code” (for example by using a whitelist or a fixed regular expression).
    • Use URL‐parsing or encoding libraries to ensure that any injected special characters are neutralized.
    • Add request timeouts and network egress filtering to prevent abuse.
    • Consider preventing external input from reaching this processing function in a public API.

  - **Preconditions:**
    The attacker must be able to control or set the `Station.code` field. This may occur if the application exposes the station–creating/updating functionality to untrusted users or if an administrator fails to validate input.

  - **Source Code Analysis:**
    1. In the file `tests/weather/models.py`, the constant
       ```
       DATA_URL = "https://www.ncei.noaa.gov/access/past-weather/{code}/data.csv"
       ```
       is defined.
    2. The method `load_weather` calls
       ```
       response = requests.get(DATA_URL.format(code=self.code))
       ```
       with no sanitation or verification of `self.code`.
    3. The fetched CSV data is parsed and inserted into the weather database.

  - **Security Test Case:**
    1. Set up a test instance using the same code (or a similar derived application) that exposes the Station creation endpoint.
    2. Create (or update) a Station record with a malicious “code” value (for example, a value containing a domain name/IP address known to be internal or under attacker control, or with additional CRLF characters to attempt URL manipulation).
    3. Trigger the `load_weather` method (either via an API call or by directly calling the method in a test).
    4. Monitor outbound HTTP requests from the server. If the request is made to the attacker–specified endpoint (or for unexpected destinations), the vulnerability is confirmed.

---

- **Vulnerability Name:** HTTP Header Injection in Content-Disposition Header
  - **Description:**
    When a pandas–based view is rendered, the helper method `get_pandas_headers` in the `PandasMixin` (located in `rest_pandas/views.py`) constructs a “Content-Disposition” header by calling:
    ```
    def get_pandas_headers(self, request):
        format = request.accepted_renderer.format
        filename = self.get_pandas_filename(request, format)
        if not filename:
            return {}

        extension = "." + format
        if not filename.endswith(extension):
            filename += extension

        return {
            "Content-Disposition": 'attachment; filename="{}"'.format(filename)
        }
    ```
    If—for whatever reason—a view overrides `get_pandas_filename` and returns a string that includes newline characters or CRLF sequences, an attacker may force unexpected headers (or inject additional HTTP headers) into the response.

  - **Impact:**
    The attacker could use HTTP header injection (or response splitting) to:
    • Manipulate HTTP responses.
    • Poison caches.
    • In some cases combine with subsequent XSS attacks to inject scripts.

  - **Vulnerability Rank:** High
  - **Currently Implemented Mitigations:**
    The default implementations provided by sample views return fixed, hardcoded filenames. However, there is no sanitation at the library level in `get_pandas_headers` to ensure that malicious characters are stripped from the filename.

  - **Missing Mitigations:**
    • Sanitize the filename by stripping any newline (`\n` / `\r`) characters or other control sequences before including it in the header.
    • Use defensive coding or built‐in libraries (or even Django’s own utilities) to safely quote header values.
    • Optionally ignore or override any user–supplied filename if it is not from a trusted source.

  - **Preconditions:**
    An attacker must be able to influence the return value of `get_pandas_filename`. This will be possible if the application (or a developer’s override) uses unsanitized external input (such as GET parameters or database values) to form the filename.

  - **Source Code Analysis:**
    1. In the base class `PandasMixin` (located in `rest_pandas/views.py`), the method `get_pandas_headers` is defined.
    2. It directly uses the return from `get_pandas_filename` (which is not sanitized in the project code) to construct the header via Python’s string formatting.
    3. No extra checks (such as filtering CR or LF characters) are performed.

  - **Security Test Case:**
    1. Create or override a view so that its `get_pandas_filename` method returns a string containing CRLF sequences (for example:
       `filename = 'report.csv\r\nInjected: malicious-header: evil'`).
    2. Invoke the vulnerable endpoint with an HTTP client.
    3. Examine the raw HTTP response headers to see if extra headers are injected.
    4. If the header is split or additional header content appears, the vulnerability is confirmed.

---

- **Vulnerability Name:** Lack of Integrity Verification for External JavaScript Dependencies in GitHub Pages Workflow
  - **Description:**
    The project’s GitHub Pages build workflow (in `.github/workflows/pages.yml`) downloads several JavaScript files directly from unpkg.com using curl:
    ```
    curl -L -s https://unpkg.com/wq > docs/js/wq.js
    curl -L -s https://unpkg.com/@wq/markdown@latest > docs/js/markdown.js
    curl -L -s https://unpkg.com/@wq/analyst@next > docs/js/analyst.js
    curl -L -s https://unpkg.com/@wq/chart@next > docs/js/chart.js
    ```
    These files are then used as part of a public-facing documentation site. There is no verification (for example, using Subresource Integrity [SRI] hashes or explicit checksum comparison) of the downloaded files.

  - **Impact:**
    An attacker who is able to compromise the external host (or perform a man–in–the–middle attack) could modify the JavaScript files. This could lead to:
    • Injection of malicious code into the client–side assets.
    • Cross–site scripting (XSS) attacks on users who visit the GitHub Pages site.
    • Broad supply–chain compromise of the web asset.

  - **Vulnerability Rank:** Critical
  - **Currently Implemented Mitigations:**
    None. The workflow downloads the scripts over HTTPS but does not perform any additional integrity checks (such as verifying expected checksums or using hard–coded SRI hashes).

  - **Missing Mitigations:**
    • Pin the external dependencies to explicit versions and verify them using SHA256 or SRI checksums.
    • Implement a post–download checksum comparison in the workflow before committing the files to the site.
    • Alternatively, vendor and maintain the JavaScript dependencies in a secure repository.

  - **Preconditions:**
    An attacker must be able to compromise the unpkg.com-hosted versions of the dependencies or intercept the connection even over HTTPS (for example, by exploiting weaknesses in the CDN or through DNS hijacking).

  - **Source Code Analysis:**
    1. In the workflow file `.github/workflows/pages.yml`, the build step downloads several JS files using curl with no integrity validation.
    2. Subsequent sed commands rewrite module import paths but do not alter the contents or perform any security checks.
    3. The downloaded files are placed under `docs/js/` and are then served to visitors.

  - **Security Test Case:**
    1. In a controlled test environment, replace one of the downloaded JavaScript files with a malicious version (simulate a compromised dependency).
    2. Run the Pages workflow locally or simulate its steps so that the modified file is used.
    3. Visit the generated documentation site and check whether the malicious JavaScript executes (for example, by triggering an alert or logging a known token).
    4. Validate that without an integrity check, the site’s asset pipeline accepts altered remote files.