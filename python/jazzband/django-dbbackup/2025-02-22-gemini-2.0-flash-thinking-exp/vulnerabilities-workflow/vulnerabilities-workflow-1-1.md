### Vulnerability List

- Vulnerability Name: Path Traversal Write via Filename Template
- Description:
    - An attacker with administrative privileges (or who has compromised an admin account) can exploit a path traversal vulnerability by manipulating the `DBBACKUP_FILENAME_TEMPLATE` or `DBBACKUP_MEDIA_FILENAME_TEMPLATE` settings.
    - Step 1: The attacker gains access to the Django admin panel or any interface that allows modification of Django settings, specifically `DBBACKUP_FILENAME_TEMPLATE` or `DBBACKUP_MEDIA_FILENAME_TEMPLATE`.
    - Step 2: The attacker modifies either `DBBACKUP_FILENAME_TEMPLATE` or `DBBACKUP_MEDIA_FILENAME_TEMPLATE` to include path traversal characters, such as `../`. For example, setting `DBBACKUP_FILENAME_TEMPLATE` to `../../../../tmp/evil_backup_{datetime}.db`.
    - Step 3: The attacker triggers a database or media backup operation, for instance, by using the `dbbackup` or `mediabackup` Django management command.
    - Step 4: The `filename_generate` function in `dbbackup/utils.py` uses the maliciously crafted template to generate the backup filename. Due to the path traversal characters, the backup file will be written to an unintended location on the server's filesystem.
- Impact:
    - By writing files to arbitrary locations, an attacker could overwrite critical system files, potentially leading to system instability or denial of service.
    - Alternatively, the attacker could write malicious files (e.g., web shells, scripts) to directories accessible by the webserver, potentially leading to arbitrary code execution and full system compromise.
- Vulnerability Rank: High
- Currently Implemented Mitigations:
    - The project includes Django system checks (W007 and W008 in `dbbackup/checks.py`) that issue a warning if the filename templates contain slashes ('/').
    - These checks are passive warnings during Django's `check` command execution and do not actively prevent path traversal during runtime or enforce input validation.
- Missing Mitigations:
    - **Input Validation:** The project lacks runtime input validation for `DBBACKUP_FILENAME_TEMPLATE` and `DBBACKUP_MEDIA_FILENAME_TEMPLATE`. It should sanitize or strictly validate these settings to disallow path traversal sequences (e.g., `../`, `..\\`, absolute paths starting with `/` or `C:\`).
    - **Path Sanitization:**  While `REG_FILENAME_CLEAN.sub("-", filename)` in `filename_generate` removes redundant hyphens, it does not prevent path traversal sequences. A robust path sanitization function should be implemented to remove or neutralize path traversal components from the generated filename before file system operations.
- Preconditions:
    - Administrative access to the Django application's settings configuration (either through Django admin panel or other configuration interfaces).
    - The application using `django-dbbackup` must allow modification of `DBBACKUP_FILENAME_TEMPLATE` or `DBBACKUP_MEDIA_FILENAME_TEMPLATE` settings without proper validation.
- Source Code Analysis:
    - `dbbackup/settings.py`: Defines `FILENAME_TEMPLATE` and `MEDIA_FILENAME_TEMPLATE` settings, which are read directly from Django's `settings`. (File not provided in PROJECT FILES, assumed from previous analysis)
    - `dbbackup/utils.py`: The `filename_generate` function uses these templates to construct the backup filename. (File not provided in PROJECT FILES, assumed from previous analysis)
    - `dbbackup/checks.py`: Includes system checks to warn about slashes in templates, but does not enforce validation or prevention. (File not provided in PROJECT FILES, assumed from previous analysis)
    - `dbbackup/management/commands/dbbackup.py` & `dbbackup/management/commands/mediabackup.py`: These commands use `utils.filename_generate` to create backup filenames.

    ```python
    # File: dbbackup/management/commands/dbbackup.py
    class Command(BaseDbBackupCommand):
        # ...
        def _save_new_backup(self, database):
            # ...
            # Get backup, schema and name
            filename = self.connector.generate_filename(self.servername) # Filename generated by connector, but template comes from settings
            # ...
            filename = self.filename or filename # Output filename can override generated filename
            # ...
            if self.path is None:
                self.write_to_storage(outputfile, filename) # Write to storage using potentially attacker-controlled filename
            else:
                self.write_local_file(outputfile, self.path) # Write to local path, attacker-controlled path is not used here, but local path might still be misused

    # File: dbbackup/management/commands/mediabackup.py
    class Command(BaseDbBackupCommand):
        # ...
        def backup_mediafiles(self):
            # ...
            if self.filename:
                filename = self.filename # Output filename can override generated filename
            else:
                extension = f"tar{'.gz' if self.compress else ''}"
                filename = utils.filename_generate( # Filename generated using template from settings
                    extension, servername=self.servername, content_type=self.content_type
                )
        # ...
        if self.path is None:
            self.write_to_storage(tarball, filename) # Write to storage using potentially attacker-controlled filename
        else:
            self.write_local_file(tarball, self.path) # Write to local path, attacker-controlled path is not used here, but local path might still be misused
    ```
    - The commands `dbbackup` and `mediabackup` use the filename generated by `utils.filename_generate` which uses the potentially vulnerable templates `DBBACKUP_FILENAME_TEMPLATE` and `DBBACKUP_MEDIA_FILENAME_TEMPLATE` from Django settings. If an attacker can modify these settings, they can control the output filename and potentially write files outside the intended backup directory.

- Security Test Case:
    1. Set up a Django project using `django-dbbackup`. Ensure you have access to Django admin panel or a similar settings configuration interface.
    2. Log in as a superuser or an administrator who has permissions to modify Django settings.
    3. Navigate to the settings configuration interface for `django-dbbackup`. This might be a custom admin page or direct access to settings.py if applicable for your test setup.
    4. Locate the setting for `DBBACKUP_FILENAME_TEMPLATE` and change its value to: `../../../../tmp/evil_backup_{datetime}.db`.
    5. Execute the database backup command, for example, using Django's `manage.py dbbackup`.
    6. After the backup command completes, check the `/tmp/` directory on the server.
    7. Verify if a file named `evil_backup_<datetime>.db` (with a timestamp in the filename) has been created in the `/tmp/` directory.
    8. If the file exists in `/tmp/`, it confirms the Path Traversal Write vulnerability. The backup file was written outside the intended backup location due to the manipulated filename template.