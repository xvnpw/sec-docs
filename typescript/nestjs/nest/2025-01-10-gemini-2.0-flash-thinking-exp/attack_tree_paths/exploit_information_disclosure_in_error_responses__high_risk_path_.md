```typescript
/*
 * This TypeScript code provides examples and best practices for mitigating the "Exploit Information Disclosure in Error Responses" attack path in a NestJS application.
 */

import {
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { BaseExceptionFilter } from '@nestjs/core';
import { Response, Request } from 'express';

@Catch()
export class AllExceptionsFilter extends BaseExceptionFilter {
  private readonly logger = new Logger(AllExceptionsFilter.name);

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    let status = HttpStatus.INTERNAL_SERVER_ERROR;
    let errorMessage = 'An unexpected error occurred.';
    const errorDetails: Record<string, any> = {
      timestamp: new Date().toISOString(),
      path: request.url,
    };

    if (exception instanceof HttpException) {
      status = exception.getStatus();
      errorMessage = exception.message;

      // IMPORTANT: Avoid exposing sensitive details from HttpException responses in production
      if (process.env.NODE_ENV !== 'production') {
        errorDetails.error = exception.getResponse(); // Include full details in non-prod for debugging
      }
    } else if (exception instanceof Error) {
      // Handle generic errors, log details, and provide a generic message to the client
      this.logger.error(`Unhandled Error: ${exception.message}`, exception.stack);
      if (process.env.NODE_ENV !== 'production') {
        errorDetails.error = exception.message;
        errorDetails.stack = exception.stack;
      }
    } else {
      // Handle other types of exceptions
      this.logger.error(`Unknown Exception: ${String(exception)}`);
      if (process.env.NODE_ENV !== 'production') {
        errorDetails.error = String(exception);
      }
    }

    response.status(status).json({
      statusCode: status,
      message: errorMessage,
      ...errorDetails,
    });

    super.catch(exception, host); // Still call the base filter for default NestJS handling (optional)
  }
}

// Example of a controller that might throw exceptions
// import { Controller, Get, Param, ParseIntPipe } from '@nestjs/common';
// import { UserService } from './user.service';

// @Controller('users')
// export class UserController {
//   constructor(private readonly userService: UserService) {}

//   @Get(':id')
//   async getUser(@Param('id', ParseIntPipe) id: number) {
//     try {
//       const user = await this.userService.findById(id);
//       if (!user) {
//         throw new HttpException('User not found', HttpStatus.NOT_FOUND);
//       }
//       return user;
//     } catch (error) {
//       // Let the global exception filter handle it
//       throw error;
//     }
//   }
// }

// Example of how NOT to handle exceptions (vulnerable):
// import { Catch, ArgumentsHost, HttpException } from '@nestjs/common';
// import { BaseExceptionFilter } from '@nestjs/core';

// @Catch()
// export class VulnerableExceptionFilter extends BaseExceptionFilter {
//   catch(exception: unknown, host: ArgumentsHost) {
//     const ctx = host.switchToHttp();
//     const response = ctx.getResponse();
//     const request = ctx.getRequest();

//     // VULNERABILITY: Directly exposing the error object which might contain sensitive data
//     response.status((exception as HttpException).getStatus() || 500).json({
//       statusCode: (exception as HttpException).getStatus() || 500,
//       timestamp: new Date().toISOString(),
//       path: request.url,
//       error: exception, // Exposes the entire exception object
//     });
//   }
// }

// Best Practices Summary:

/**
 * 1. **Global Exception Filters:** Implement a global exception filter to centralize error handling and ensure consistent responses.
 * 2. **Production vs. Development Environments:** Differentiate error responses based on the environment. Provide detailed errors in development but generic messages in production.
 * 3. **Avoid Exposing Sensitive Data:**  Never include database credentials, internal file paths, API keys, or other sensitive information directly in error responses.
 * 4. **Use Generic Error Messages:** Provide user-friendly, generic error messages to the client.
 * 5. **Secure Logging:** Log detailed error information securely on the server-side for debugging and monitoring. Ensure these logs are not publicly accessible.
 * 6. **Sanitize Error Messages:** If you must include specific error details, sanitize them to remove any sensitive information.
 * 7. **Handle Different Exception Types:**  Implement logic to handle different types of exceptions appropriately.
 * 8. **Input Validation:** Implement robust input validation to prevent errors caused by malformed or unexpected input.
 * 9. **Regular Security Audits:** Conduct regular security audits and penetration testing to identify potential information disclosure vulnerabilities.
 * 10. **Environment Variables:** Store sensitive configuration details (like database credentials) in environment variables, not directly in the code.
 */
```